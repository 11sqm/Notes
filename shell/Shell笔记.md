# Shell笔记
---
笔记参考教程为[The missing semester of your CS education](https://missing-semester-cn.github.io/)，仅仅是作为学习记录，未经允许不得转载。
## 主题1: The Shell
### 1. shell基础
shell是一个编程环境，具备变量、条件、循环和函数。在shell执行命令时，实际上时执行一段shell可以解释执行的简短代码。

shell基于空格对命令进行解析，然后执行第一个单词代表的程序，并将后续单词作为程序可访问的参数。例如：
```shell
lzl:~$ echo hello
hello
```
此处 `echo` 程序可将参数打印在终端上进行显示。

对于不是shell所了解的变成关键字，它会咨询*环境变量* `$PATH` ，它会列出当shell接到某条指令时，进行程序搜索的路径。 `$PATH` 中一系列目录由 `:` 进行分割。确定某个程序名代表的是哪个具体的程序，可以使用 `which` 程序。我们也可以绕过 `$PATH`，通过直接指定需要执行的程序的路径来执行该程序。示例如下：
```shell
lzl:~$ which echo
/bin/echo
lzl:~$ /bin/echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

### 2. shell中导航
shell总路径时一组被分割的目录，在Linux中使用 `/` 分割，在Windows上是 `\` 。路径 `/` 代表系统的根目录，所有文件夹包含在这个路径下，Windows中每个盘有一个根目录（如 `C:\` ）。

对于Linux系统，如果某个路径以 `/` 开头，则它是一个绝对路径，其他的都是相对路径。相对路径指相对当前工作目录的路径。`pwd` 命令可以获取当前工作目录。`cd` 命令用于切换目录。路径中，`.` 表示当前目录，而 `..` 表示上级目录。

一般来说，当运行一个程序时，如果没有指定路径，则程序会在当前目录下执行。

为了查看目录下包含文件，可以使用 `ls` 命令，此时会打印当前目录下的文件。多数命令接受标记和选项，它们以 `-` 开头，可以改变程序行为。通常，在执行程序时使用 `-h` 或 `--help` 标记可以打印帮助信息，以便了解有哪些可用的标记或选项。对于`ls` 命令，`-l` 参数可以详细列出目录下文件或文件夹信息。
```shell
lzl:~$ ls -l /home
drwxr-xr-x 1 lzl  users  4096 Dec 16  2025 lzl 
```
首先，本行第一个字符 `d` 表示 `lzl` 是一个目录。然后接下来的九个字符，每三个字符构成一组。`rwx` 它们分别代表了文件所有者（`lzl`），用户组（`users`） 以及其他所有人具有的权限。其中 `-` 表示该用户不具备相应的权限。**`w` 为写权限**，上例中表明只有文件所有这可以修改 `lzl` 文件夹，如添加或删除文件夹中的文件。**`x` 为可执行权限**，上例中表明用户是否具备该文件夹及其父文件夹的搜索权限，从而可以进入文件夹。**`r` 为读权限**，上例中表示用户能否列出它的包含内容。

此外还有部分指令，如`mv` 指令用于重命名或移动文件，`cp` 指令用于拷贝文件，`mkdir` 指令用于新建文件夹。对于所需程序参数，输入输出信息，或工作方式，可以使用 `man` 程序获取，它通过接受程序名作为参数，然后将它的文档展现。

### 3. 在程序间创建连接
在 shell 中，程序有两个主要的“流”：它们的输入流和输出流。当程序尝试读取信息时，它们会从输入流中进行读取，当程序打印信息时，它们会将信息输出到输出流中。通常，一个程序输入输出留都是终端，但是这些流也可以重定向。

最简单的重定向是 `< file` 和 `> file`。这两个命令可以将程序输入输出重定向到文件。
```shell
lzl:~$ echo hello > hello.txt
lzl:~$ cat hello.txt
hello
lzl:~$ cat < hello.txt
hello
lzl:~$ cat < hello.txt > hello2.txt
lzl:~$ cat hello2.txt
hello
```
此外还可以使用 `>>` 向文件追加内容。使用管道进行文件重定向。`|` 操作符允许将一个程序的输出和另外一个程序的输入连接起来。

### 4. 根用户
类Unix系统中，根用户十分特殊，其几乎不受任何限制，可以创建、读取、更新和删除系统中的任何文件。通常不会以根用户身份直接登陆系统，因为可能会由于某些错误操作而破坏系统。取而代之的是在需要的时候使用 `sudo` 命令，作用是可以以super user身份执行一些操作。

例如，要更改屏幕亮度，由于 `|`、`>`和 `<` 是通过shell执行的，而不是被各个程序单独执行。 `echo` 等程序并不知道 `|` 的存在，它们只知道从自己的输入输出流中进行读写。所以shell操作应当为：
```shell
$ sudo find -L /sys/class/backlight -maxdepth 2 -name '*brightness*'
/sys/class/backlight/thinkpad_screen/brightness
$ cd /sys/class/backlight/thinkpad_screen
$ echo 3 | sudo tee brightness
```

### 5. shell脚本
大多数shell都有自己的一套脚本语言，包括变量、控制流和自己的语法。shell脚本与其他脚本语言不同之处在于，shell脚本针对shell所从事的相关工作进行了优化。

bash中为变量赋值的语法是 `foo=bar`，访问变量中存储的数值，其语法为 `$foo`。需要注意的是，`foo = bar` 是不能正确工作的，因为解释器会调用程序 `foo` 并将 `=` 和 `bar` 作为参数。总的来说，在shell脚本中使用空格会起到分割参数的作用，有时候可能会造成混淆。

Bash中的字符通过 `'` 和 `"` 分隔符来定义，但是含义不同。`'` 定义的字符串为原义字符串，其中的变量不会被转义，而 `"` 定义的字符串会将变量值进行替换。

```shell
foo=bar
echo "$foo"
# 打印 bar
echo '$foo'
# 打印 $foo
```
bash支持 `if` , `case` , `while` 和 `for` 这些控制流关键字。
1. for语句的结构
```shell
for 变量名 in 取值列表
do
    命令序列
done
```
2. while语句结构
```shell
while 条件测试操作
do
    命令序列
done
```
3. case语句结构
```shell
case 变量值 in
模式1)
    命令序列1
    ;;
模式2)
    命令序列2
    ;;
    ......
*)
    默认命令序列
esac
```
使用case分支语句是，应当注意以下特点：
- case行尾必须为单词“in”，每一个模式必须以右括号“)”结束。
- 双分号“;;”表示命令序列的结束。
- 模式字符串中，可以用方括号表示一个连续的范围，如“[0-9]”；还可以用“|”表示或，如“A|B”。
- “\*)”表示默认模式，其中的“\*”相当于通配符。
示例如下：
```shell
#!/bin/bash
read -p "请输入一个字符,并按Enter键确认:" KEY
case "$KEY" in
  [a-z] | [A-Z])
     echo “您输入的是 字母.”
     ;;
  [0-9])
     echo “您输入的是 数字.”
     ;;
  *)
     echo “您输入的是 空格、功能键或其他控制字符.”
esac
```
4. if语句结构
```shell
if condition1
then
    command1
elif condition2 
then 
    command2
else
    commandN
fi
```
if else 的 `[[...]]` 判断语句中大于使用 `-gt`，小于使用 `-lt`。如果使用 `((...))` 作为判断语句，大于和小于可以直接使用 `>` 和 `<`。在 `bash` 中进行比较时，尽量使用双方括号 `[[ ]]` 而不是单方括号 `[ ]`，这样会降低犯错的几率，尽管这样并不能兼容 `sh`。
示例如下：
```shell
#!/bin/bash
a=10
b=20
if [[ $a == $b ]]
then
   echo "a 等于 b"
elif [[ $a -gt $b ]]
then
   echo "a 大于 b"
elif [[ $a -lt $b ]]
then
   echo "a 小于 b"
else
   echo "没有符合的条件"
fi
```

同样地，bash也支持函数，它可以接受参数并基于参数进行操作。下面这个函数是一个例子，它会创建一个文件夹并使用 `cd` 进入该文件夹。
```shell
mcd () {
    mkdir -p "$1"
    cd "$1"
}
```
这里 `$1` 是脚本的第一个参数。与其他脚本语言不同的是，bash使用了很多特殊的变量来表示参数、错误代码和相关变量。以下为部分变量。
- `$0` - 脚本名
- `$1` 到 `$9` - 脚本的参数。`$1` 是第一个参数，依此类推。
- `$@` - 所有参数
- `$#` - 参数个数
- `$?` - 前一个命令的返回值
- `$$` - 当前脚本的进程识别码
- `!!` - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 sudo !! 再尝试一次。
- `$_` - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 Esc 之后键入 `.` 来获取这个值。

命令通常使用 `STDOUT` 来返回输出值，使用 `STDERR` 来返回错误及错误码，便于脚本以更加友好的方式报告错误。返回码或退出状态是脚本/命令之间交流执行状态的方式。返回值0表示正常执行，其他所有非0的返回值都表示有错误发生。

退出码可以搭配 `&&`（与操作符）和 `||`（或操作符）使用，用来进行条件判断，决定是否执行其他程序。它们都属于短路运算符（short-circuiting）。同一行的多个命令可以用 `;` 分隔。程序 `true` 的返回码永远是 `0`，`false` 的返回码永远是 `1`。

此外还可以通过变量的形式获取一个命令的输出，即通过命令替换实现。通过 `$(CMD)` 的方式执行 `CMD` 这个命令是，它的输出结果会替换掉 `$(CMD)`。例如，如果执行 `for file in $(ls)`，shell首先调用 `ls`，然后遍历得到的这些返回值。

还有一个冷门的类似特性是进程替换，`<(CMD)` 会执行 `CMD` 并将结果输出到一个临时文件中，并将 `<(CMD)` 替换成临时文件名。这在我们希望返回值通过文件而不是 STDIN 传递时很有用。例如，`diff <(ls foo) <(ls bar)` 会显示文件夹 `foo` 和 `bar` 中文件的区别。

具体示例可参考该[文件](./check_foobar.sh)。

当执行脚本时，我们经常需要提供形式类似的参数。bash使我们可以轻松的实现这一操作，它可以基于文件扩展名展开表达式。这一技术被称为shell的通配。

- 通配符 - 当你想要利用通配符进行匹配时，你可以分别使用 `?` 和 `*` 来匹配一个或任意个字符。
- 花括号 `{}` - 当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。

注意，脚本并不一定只有用 bash 写才能在终端里调用。比如说，这是一段 Python 脚本，作用是将输入的参数倒序输出：
```python
#!/usr/local/bin/python
import sys
for arg in reversed(sys.argv[1:]):
    print(arg)
```
内核知道去用 python 解释器而不是shell命令来运行这段脚本，是因为脚本的开头第一行的 `shebang`。在 `shebang` 行中使用 `env` 命令是一种好的实践，它会利用环境变量中的程序来解析该脚本，这样就提高了您的脚本的可移植性。`env` 会利用 `PATH` 环境变量来进行定位。

shell函数和脚本有如下不同点：
- 函数只能与 shell 使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 `shebang` 是很重要的。
- 函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。
- 函数会在当前的 shell 环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。使用 `export` 导出的环境变量会以传值的方式传递给脚本。
- 与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell 脚本中往往也会包含它们自己的函数定义。