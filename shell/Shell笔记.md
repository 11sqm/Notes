# Shell笔记
---
笔记参考教程为[The missing semester of your CS education](https://missing-semester-cn.github.io/)，仅仅是作为学习记录，未经允许不得转载。
## 主题1: The Shell
### 1. shell基础
shell是一个编程环境，具备变量、条件、循环和函数。在shell执行命令时，实际上时执行一段shell可以解释执行的简短代码。

shell基于空格对命令进行解析，然后执行第一个单词代表的程序，并将后续单词作为程序可访问的参数。例如：
```shell
lzl:~$ echo hello
hello
```
此处 `echo` 程序可将参数打印在终端上进行显示。

对于不是shell所了解的变成关键字，它会咨询*环境变量* `$PATH` ，它会列出当shell接到某条指令时，进行程序搜索的路径。 `$PATH` 中一系列目录由 `:` 进行分割。确定某个程序名代表的是哪个具体的程序，可以使用 `which` 程序。我们也可以绕过 `$PATH`，通过直接指定需要执行的程序的路径来执行该程序。示例如下：
```shell
lzl:~$ which echo
/bin/echo
lzl:~$ /bin/echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

### 2. shell中导航
shell总路径时一组被分割的目录，在Linux中使用 `/` 分割，在Windows上是 `\` 。路径 `/` 代表系统的根目录，所有文件夹包含在这个路径下，Windows中每个盘有一个根目录（如 `C:\` ）。

对于Linux系统，如果某个路径以 `/` 开头，则它是一个绝对路径，其他的都是相对路径。相对路径指相对当前工作目录的路径。`pwd` 命令可以获取当前工作目录。`cd` 命令用于切换目录。路径中，`.` 表示当前目录，而 `..` 表示上级目录。

一般来说，当运行一个程序时，如果没有指定路径，则程序会在当前目录下执行。

为了查看目录下包含文件，可以使用 `ls` 命令，此时会打印当前目录下的文件。多数命令接受标记和选项，它们以 `-` 开头，可以改变程序行为。通常，在执行程序时使用 `-h` 或 `--help` 标记可以打印帮助信息，以便了解有哪些可用的标记或选项。对于`ls` 命令，`-l` 参数可以详细列出目录下文件或文件夹信息。
```shell
lzl:~$ ls -l /home
drwxr-xr-x 1 lzl  users  4096 Dec 16  2025 lzl 
```
首先，本行第一个字符 `d` 表示 `lzl` 是一个目录。然后接下来的九个字符，每三个字符构成一组。`rwx` 它们分别代表了文件所有者（`lzl`），用户组（`users`） 以及其他所有人具有的权限。其中 `-` 表示该用户不具备相应的权限。**`w` 为写权限**，上例中表明只有文件所有这可以修改 `lzl` 文件夹，如添加或删除文件夹中的文件。**`x` 为可执行权限**，上例中表明用户是否具备该文件夹及其父文件夹的搜索权限，从而可以进入文件夹。**`r` 为读权限**，上例中表示用户能否列出它的包含内容。

此外还有部分指令，如`mv` 指令用于重命名或移动文件，`cp` 指令用于拷贝文件，`mkdir` 指令用于新建文件夹。对于所需程序参数，输入输出信息，或工作方式，可以使用 `man` 程序获取，它通过接受程序名作为参数，然后将它的文档展现。

### 3. 在程序间创建连接
在 shell 中，程序有两个主要的“流”：它们的输入流和输出流。当程序尝试读取信息时，它们会从输入流中进行读取，当程序打印信息时，它们会将信息输出到输出流中。通常，一个程序输入输出留都是终端，但是这些流也可以重定向。

最简单的重定向是 `< file` 和 `> file`。这两个命令可以将程序输入输出重定向到文件。
```shell
lzl:~$ echo hello > hello.txt
lzl:~$ cat hello.txt
hello
lzl:~$ cat < hello.txt
hello
lzl:~$ cat < hello.txt > hello2.txt
lzl:~$ cat hello2.txt
hello
```
此外还可以使用 `>>` 向文件追加内容。使用管道进行文件重定向。`|` 操作符允许将一个程序的输出和另外一个程序的输入连接起来。

### 4. 根用户
类Unix系统中，根用户十分特殊，其几乎不受任何限制，可以创建、读取、更新和删除系统中的任何文件。通常不会以根用户身份直接登陆系统，因为可能会由于某些错误操作而破坏系统。取而代之的是在需要的时候使用 `sudo` 命令，作用是可以以super user身份执行一些操作。

例如，要更改屏幕亮度，由于 `|`、`>`和 `<` 是通过shell执行的，而不是被各个程序单独执行。 `echo` 等程序并不知道 `|` 的存在，它们只知道从自己的输入输出流中进行读写。所以shell操作应当为：
```shell
$ sudo find -L /sys/class/backlight -maxdepth 2 -name '*brightness*'
/sys/class/backlight/thinkpad_screen/brightness
$ cd /sys/class/backlight/thinkpad_screen
$ echo 3 | sudo tee brightness
```

### 5. shell脚本
大多数shell都有自己的一套脚本语言，包括变量、控制流和自己的语法。shell脚本与其他脚本语言不同之处在于，shell脚本针对shell所从事的相关工作进行了优化。

bash中为变量赋值的语法是 `foo=bar`，访问变量中存储的数值，其语法为 `$foo`。需要注意的是，`foo = bar` 是不能正确工作的，因为解释器会调用程序 `foo` 并将 `=` 和 `bar` 作为参数。总的来说，在shell脚本中使用空格会起到分割参数的作用，有时候可能会造成混淆。

Bash中的字符通过 `'` 和 `"` 分隔符来定义，但是含义不同。`'` 定义的字符串为原义字符串，其中的变量不会被转义，而 `"` 定义的字符串会将变量值进行替换。

```shell
foo=bar
echo "$foo"
# 打印 bar
echo '$foo'
# 打印 $foo
```
bash支持 `if` , `case` , `while` 和 `for` 这些控制流关键字。
1. for语句的结构
```shell
for 变量名 in 取值列表
do
    命令序列
done
```
2. while语句结构
```shell
while 条件测试操作
do
    命令序列
done
```
3. case语句结构
```shell
case 变量值 in
模式1)
    命令序列1
    ;;
模式2)
    命令序列2
    ;;
    ......
*)
    默认命令序列
esac
```
使用case分支语句是，应当注意以下特点：
- case行尾必须为单词“in”，每一个模式必须以右括号“)”结束。
- 双分号“;;”表示命令序列的结束。
- 模式字符串中，可以用方括号表示一个连续的范围，如“[0-9]”；还可以用“|”表示或，如“A|B”。
- “\*)”表示默认模式，其中的“\*”相当于通配符。
示例如下：
```shell
#!/bin/bash
read -p "请输入一个字符,并按Enter键确认:" KEY
case "$KEY" in
  [a-z] | [A-Z])
     echo “您输入的是 字母.”
     ;;
  [0-9])
     echo “您输入的是 数字.”
     ;;
  *)
     echo “您输入的是 空格、功能键或其他控制字符.”
esac
```
4. if语句结构
```shell
if condition1
then
    command1
elif condition2 
then 
    command2
else
    commandN
fi
```
if else 的 `[[...]]` 判断语句中大于使用 `-gt`，小于使用 `-lt`。如果使用 `((...))` 作为判断语句，大于和小于可以直接使用 `>` 和 `<`。在 `bash` 中进行比较时，尽量使用双方括号 `[[ ]]` 而不是单方括号 `[ ]`，这样会降低犯错的几率，尽管这样并不能兼容 `sh`。

**常用的测试表达式**：
- **文件测试**: -e: 检查文件是否存在。 -f: 检查是否为普通文件。 -d: 检查是否为目录。
- **权限测试**: -r: 文件可读。 -w: 文件可写。 -x: 文件可执行。
- **字符串比较**: =: 检查两个字符串是否相等。 !=: 检查两个字符串是否不相等。
- **整数比较**: -eq: 等于。 -ne: 不等于。 -gt: 大于。 -lt: 小于。 -ge: 大于等于。 -le: 小于等于。
示例如下：
```shell
#!/bin/bash
a=10
b=20
if [[ $a == $b ]]
then
   echo "a 等于 b"
elif [[ $a -gt $b ]]
then
   echo "a 大于 b"
elif [[ $a -lt $b ]]
then
   echo "a 小于 b"
else
   echo "没有符合的条件"
fi
```

同样地，bash也支持函数，它可以接受参数并基于参数进行操作。下面这个函数是一个例子，它会创建一个文件夹并使用 `cd` 进入该文件夹。
```shell
mcd () {
    mkdir -p "$1"
    cd "$1"
}
```
这里 `$1` 是脚本的第一个参数。与其他脚本语言不同的是，bash使用了很多特殊的变量来表示参数、错误代码和相关变量。以下为部分变量，具体可以参考此[网站](https://tldp.org/LDP/abs/html/special-chars.html)。
- `$0` - 脚本名
- `$1` 到 `$9` - 脚本的参数。`$1` 是第一个参数，依此类推。
- `$@` - 所有参数
- `$#` - 参数个数
- `$?` - 前一个命令的返回值
- `$$` - 当前脚本的进程识别码
- `!!` - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 sudo !! 再尝试一次。
- `$_` - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 Esc 之后键入 `.` 来获取这个值。

命令通常使用 `STDOUT` 来返回输出值，使用 `STDERR` 来返回错误及错误码，便于脚本以更加友好的方式报告错误。返回码或退出状态是脚本/命令之间交流执行状态的方式。返回值0表示正常执行，其他所有非0的返回值都表示有错误发生。

退出码可以搭配 `&&`（与操作符）和 `||`（或操作符）使用，用来进行条件判断，决定是否执行其他程序。它们都属于短路运算符（short-circuiting）。同一行的多个命令可以用 `;` 分隔。程序 `true` 的返回码永远是 `0`，`false` 的返回码永远是 `1`。

此外还可以通过变量的形式获取一个命令的输出，即通过命令替换实现。通过 `$(CMD)` 的方式执行 `CMD` 这个命令是，它的输出结果会替换掉 `$(CMD)`。例如，如果执行 `for file in $(ls)`，shell首先调用 `ls`，然后遍历得到的这些返回值。

还有一个冷门的类似特性是进程替换，`<(CMD)` 会执行 `CMD` 并将结果输出到一个临时文件中，并将 `<(CMD)` 替换成临时文件名。这在我们希望返回值通过文件而不是 STDIN 传递时很有用。例如，`diff <(ls foo) <(ls bar)` 会显示文件夹 `foo` 和 `bar` 中文件的区别。

具体示例可参考该[文件](./scripts/check_foobar.sh)。

当执行脚本时，我们经常需要提供形式类似的参数。bash使我们可以轻松的实现这一操作，它可以基于文件扩展名展开表达式。这一技术被称为shell的通配。

- 通配符 - 当你想要利用通配符进行匹配时，你可以分别使用 `?` 和 `*` 来匹配一个或任意个字符。
- 花括号 `{}` - 当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。
    ```shell
    convert image.{png,jpg}
    # 会展开为
    convert image.png image.jpg

    cp /path/to/project/{foo,bar,baz}.sh /newpath
    # 会展开为
    cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath

    # 也可以结合通配使用
    mv *{.py,.sh} folder
    # 会移动所有 *.py 和 *.sh 文件

    mkdir foo bar

    # 下面命令会创建 foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h 这些文件
    touch {foo,bar}/{a..h}
    touch foo/x bar/y
    # 比较文件夹 foo 和 bar 中包含文件的不同
    diff <(ls foo) <(ls bar)
    # 输出
    # < x
    # ---
    # > y
    ```

注意，脚本并不一定只有用 bash 写才能在终端里调用。比如说，这是一段 Python 脚本，作用是将输入的参数倒序输出：
```python
#!/usr/local/bin/python
import sys
for arg in reversed(sys.argv[1:]):
    print(arg)
```
内核知道去用 python 解释器而不是shell命令来运行这段脚本，是因为脚本的开头第一行的 `shebang`。在 `shebang` 行中使用 `env` 命令是一种好的实践，它会利用环境变量中的程序来解析该脚本，这样就提高了您的脚本的可移植性。`env` 会利用 `PATH` 环境变量来进行定位。

shell函数和脚本有如下不同点：
- 函数只能与 shell 使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 `shebang` 是很重要的。
- 函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。
- 函数会在当前的 shell 环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。使用 `export` 导出的环境变量会以传值的方式传递给脚本。
- 与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell 脚本中往往也会包含它们自己的函数定义。

### 6. shell工具
#### (1) 查找文件
所有类UNIX系统包含 `find` 工具，用于查找文件。`find` 命令会递归搜索符合条件的文件，如：
```shell
# 查找所有名称为src的文件夹
find . -name src -type d
# 查找所有文件夹路径中包含test的python文件
find . -path '*/test/*.py' -type f
# 查找前一天修改的所有文件
find . -mtime -1
# 查找所有大小在500k至10M的tar.gz文件
find . -size +500k -size -10M -name '*.tar.gz'
```
除了列出所寻找的文件之外，`find` 还能对所有查找到的文件进行操作。这能极大地简化一些单调的任务。
```shell
# 删除全部扩展名为.tmp 的文件
find . -name '*.tmp' -exec rm {} \;
# 查找全部的 PNG 文件并将其转换为 JPG
find . -name '*.png' -exec magick {} {}.jpg \;
```
尽管 `find` 用途广泛，它的语法却比较难以记忆。`fd` 则是一个更简单、更快速、更友好的程序，可以作为 `find` 的替代品。以模式 `PATTERN` 搜索的语法是 `fd PATTERN`.

#### (2) 查找代码
为查看文件内容，查找具有某种模式的全部文件，并找到位置，可以使用 `grep` 命令。它是用于对输入文本进行匹配的通用工具。

其基本语法为
```shell
grep [选项] "搜索模式" 目标文件/目录/输入
```

`grep` 常用选项有如下：
- `-C` ：获取查找结果的上下文(Context)。
- `-v` ：对结果进行防眩，输出不匹配的结果(Invert)。
- `-R` ：当需要搜索大量文件时，递归进入子目录并搜索所有文本文件。

#### (3) 查找shell命令
shell中按向上方向键会显示使用过的上一条命令，继续则会遍历整个历史记录。

`history` 命令允许以程序员方式访问shell中输入的历史命令。如果要搜索历史记录，则可以利用管道将输出结果传递给 `grep` 进行模式搜索。`history | grep find` 会打印包含find子串的命令。

## 主题2：数据整理
### 1. sed
`sed` 是一个基于文本编辑器 `ed` 构建的流编辑器。在 `sed` 中，可以使用简短的命令修改文件，而不是直接操作文件内容。常用 `s` 命令，即替换命令，语法如下：
```shell
s/REGEX/SUBSTITUTION/
```
其中 `REGEX` 部分为所需要的正则表达式，而 `SUBSTITUTION` 为用于替换匹配结果的文本。

此外，`sed` 还可以用于文本注入（使用 `i` 命令），打印特定行（使用 `p` 命令），基于索引选择特定行等等。详情参考 `man sed`。

### 2. 正则表达式
正则表达式通常以 `/` 开始和结束。大多数的 ASCII 字符都表示它们本来的含义，但是有一些字符确实具有表示匹配行为的“特殊”含义。常见模式有：
- `.` 除换行符之外的“任意单个字符”
- `*` 匹配签名字符零次或多次
- `+` 匹配前面字符一次或多次
- `[abc]` 匹配 `a`，`b` 和 `c` 中的任意一个
- `(RX1|RX2)` 任何能够匹配 `RX1` 或 `RX2` 的结果
- `^` 行首，在 `[]` 内部开头 时，含义是 “取反”
- `$` 行尾

`sed` 的正则表达式有些时候是比较奇怪的，需要在这些模式前添加 `\` 才能使其具有特殊含义，或者添加 `-E` 选项来支持这些匹配。

`*` 和 `+` 在默认情况下是贪婪模式，它们会尽可能多的匹配文本。对于某些正则表达式的实现，可以给 `*` 或 `+` 增加一个 `?` 后缀使其变为非贪婪模式，但是需要注意的是 `sed` 并不支持该后缀。

对于如下命令：
```shell
| sed -E 's/.*Disconnected from (invalid |authenticating )?user .* [^ ]+ port [0-9]+( \[preauth\])?$//'
```
为了方便起见，不妨假设数据如下：
```
Jan 17 03:13:00 thesquareplanet.com sshd[2631]: Disconnected from invalid user Disconnected from 46.97.239.16 port 55920 [preauth]
```
正则表达式开头匹配任何以若干任意字符开头，并接着包含“Disconnected from”的字符串。随后，匹配两种类型 “user”。再然后匹配属于用户名的所有字符。接着再匹配任意一个单词，`[^ ]+` 会匹配任意非空且不包含空格的序列。紧接着后面匹配单“port”和它后面的一串数字，以及可能存在的后缀 `[preauth]`，最后再匹配行尾。

该指令将日志内容全部替换为空字符串，整个日志内容因此都被删除。为*保留*如用户名等信息，可以使用**捕获组**（capture groups）完成。被圆括号内的正则表达式匹配到的文本，都会被存入一系列以编号区分的捕获组中。捕获组的内容可以在替换字符串时使用（有些正则表达式的引擎甚至支持替换表达式本身），例如 `\1`、 `\2`、`\3` 等等。因此，命令可修改如下：
```shell
| sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
```